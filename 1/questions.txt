Контрольные вопросы к лабораторной работе №1

1. Методы распараллеливания и модели программ, поддерживаемые OpenMP

OpenMP поддерживает два основных метода распараллеливания:

- Распараллеливание с использованием нитей (потоков): OpenMP создаёт несколько потоков, которые могут выполнять определённые части программы одновременно. Потоки могут совместно использовать переменные или иметь свои локальные копии.
- Модели программ, поддерживаемые OpenMP:
  - Модель общей памяти: Все потоки имеют доступ к общей памяти. Это позволяет им обмениваться данными через общие переменные.
  - Форк-джоин модель: Программа начинается с одного потока (master). В местах, где стоит директива `#pragma omp parallel`, создаётся группа дополнительных потоков (fork), которые выполняют код параллельно. После выполнения параллельного участка потоки завершаются (join), и остаётся только основной поток.

2. Пояснить основные принципы выполнения ниже указанных директив.

Директива `#pragma omp parallel [clause clause ...]`
Эта директива создаёт параллельный регион, в котором несколько потоков выполняют код одновременно.

Ключевые параметры (clause):
- `if(условие)`: Параллельная секция выполняется только, если условие истинно.
- `private(list)`: Каждому потоку выделяется своя копия переменных из списка.
- `shared(list)`: Переменные в списке разделяются между потоками, то есть все потоки имеют доступ к одной и той же переменной.
- `firstprivate(list)`: Каждому потоку даётся копия переменной, инициализированная значением переменной из основного потока.
- `copyin(list)`: Потоки получают копии переменных с начальными значениями, соответствующими значению в основной нити.
- `reduction(operator:list)`: Выполняет операцию редукции (например, суммирование) над переменными в списке, объединяя результаты всех потоков.

Директива `#pragma omp for [clause clause ...]`
Используется для параллельного выполнения циклов. Каждому потоку выделяется своя часть итераций цикла.

Ключевые параметры (clause):
- `schedule(type[,chunk])`: Определяет, как распределяются итерации цикла между потоками. Типы `schedule`:
  - `static`: итерации равномерно распределяются между потоками.
  - `dynamic`: каждый поток получает новую порцию итераций по мере завершения предыдущей.
  - `guided`: подобно dynamic, но с уменьшением размера порции итераций.
- `ordered`: Требует, чтобы итерации выполнялись в порядке их следования.
- `private(list)`: Переменные из списка приватные для каждого потока.
- `shared(list)`: Переменные разделяются между потоками.
- `firstprivate(list)`: Приватные переменные инициализируются начальными значениями из основной нити.
- `lastprivate(list)`: Последняя итерация цикла передаёт значение переменных в основной поток.
- `reduction(operator:list)`: Объединяет результаты вычислений по определённому оператору (например, суммирование).
- `nowait`: Потоки не будут ждать завершения остальных потоков после выполнения параллельной секции.

Директива `#pragma omp sections [clause clause ...]`
Директива позволяет разделить код на несколько независимых секций, каждая из которых может выполняться параллельно.

Ключевые параметры (clause):
- `private(list)`: Каждая секция получает свою копию переменных.
- `firstprivate(list)`: Переменные инициализируются значениями из основной нити.
- `lastprivate(list)`: Последняя секция передаёт значение переменной в основную нить.
- `reduction(operator:list)`: Выполняет операцию редукции над переменными.
- `nowait`: Убирает ожидание окончания всех секций перед тем, как продолжить выполнение основной программы.

Директива `#pragma omp single [clause clause ...]`
Этот участок кода будет выполняться только одним потоком.

Ключевые параметры (clause):
- `private(list)`: Переменные приватны для одного потока.
- `firstprivate(list)`: Приватные переменные инициализируются значениями из основной нити.
- `nowait`: Убирает ожидание окончания выполнения участка.

Директивы синхронизации
- `#pragma omp master`: Код выполняется только главным потоком (master).
- `#pragma omp critical[name]`: Код выполняется только одним потоком одновременно. Если указан `name`, несколько критических секций с разными именами могут выполняться параллельно.
- `#pragma omp barrier`: Останавливает выполнение всех потоков до тех пор, пока все потоки не дойдут до этой точки.
- `#pragma omp atomic`: Выполняет атомарные операции (например, инкремент переменной) для предотвращения гонок данных.

3. Как задаются параллельные процессы при умножении матрицы на вектор и матрицы на матрицу в OpenMP?

Умножение матрицы на вектор
Обычно для умножения матрицы на вектор в OpenMP параллелизуются строки матрицы. Каждый поток отвечает за вычисление одной или нескольких строк результирующего вектора. При использовании директивы `#pragma omp for`, итерации цикла, обрабатывающего строки матрицы, распределяются между потоками. Пример:

```c
#pragma omp parallel for
for (int i = 0; i < M; i++) {
    for (int j = 0; j < N; j++) {
        c[i] += A[i][j] * b[j];
    }
}